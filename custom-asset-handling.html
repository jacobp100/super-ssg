<!DOCTYPE html><html><head><title>Custom Asset Handling</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><style>@font-face{font-family:"IBM Plex";src:url(https://jacobp100.github.io/super-ssg/res/92671ede.woff2)}@font-face{font-family:"IBM Plex";font-weight:700;src:url(https://jacobp100.github.io/super-ssg/res/37dc41f5.woff2)}@font-face{font-family:"IBM Plex";font-style:italic;src:url(https://jacobp100.github.io/super-ssg/res/be45b905.woff2)}@font-face{font-family:"IBM Plex";font-weight:700;font-style:italic;src:url(https://jacobp100.github.io/super-ssg/res/8c41f7c6.woff2)}@font-face{font-family:"IBM Plex Mono";src:url(https://jacobp100.github.io/super-ssg/res/e51cf30b.woff2)}@font-face{font-family:"IBM Plex Mono";font-weight:700;src:url(https://jacobp100.github.io/super-ssg/res/4dc2d08f.woff2)}:root{--f:1;--e:12px}body{margin:var(--e) var(--e) calc(var(--e)*2);font-family:"IBM Plex",sans-serif;--b:16;--c:22;background:#fdf6e3;color:#657b83}*,::after,::before{box-sizing:border-box}*{font-size:calc(var(--b)*var(--g));line-height:calc(var(--c)*var(--g));letter-spacing:calc(var(--d)*var(--g));--g:calc(
    (var(--f) * 1rem / 16) +
      ((1 - var(--f)) * 1px)
  )}h1,h2{--d:-1;font-weight:700}h1{margin:42px 0 18px;--b:32;--c:48}h2{margin:36px 0 18px;--b:24;--c:32}p{margin:16px 0}a{color:#2aa198}code,pre{background:#eee8d5;border-radius:3px}pre{padding:12px var(--e);margin:24px calc(-1*var(--e));overflow-x:scroll}code{font-family:"IBM Plex Mono",monospace;padding:2px 8px;word-break:break-all}pre code{background:0 0;padding:0;border-radius:0;word-break:initial}@media (min-width:768px){:root{--e:24px}body{display:grid;grid:1fr/275px minmax(0,100%);height:100%;column-gap:48px}code{word-break:initial}}</style><link href="https://jacobp100.github.io/super-ssg/res/5e59002e.css" rel="stylesheet"/></head><body><nav class="a"><div class="b"><a href="/" class="c">Super SSG</a><a class="d" href="#menu">Menu</a></div><div id="menu" class="e"><a class="d f" href="#">Close</a><h6 class="g">Introduction</h6><ul class="h"><li><a href="https://jacobp100.github.io/super-ssg/" class="i">Super SSG</a></li><li><a href="https://jacobp100.github.io/super-ssg/structure" class="i">Structure</a></li><li><a href="https://jacobp100.github.io/super-ssg/config" class="i">Config</a></li><li><a href="https://jacobp100.github.io/super-ssg/pages" class="i">Pages</a></li></ul><h6 class="g">Components</h6><ul class="h"><li><a href="https://jacobp100.github.io/super-ssg/a" class="i">A</a></li><li><a href="https://jacobp100.github.io/super-ssg/image" class="i">Image</a></li><li><a href="https://jacobp100.github.io/super-ssg/svg" class="i">SVG</a></li><li><a href="https://jacobp100.github.io/super-ssg/video" class="i">Video</a></li></ul><h6 class="g">Assets</h6><ul class="h"><li><a href="https://jacobp100.github.io/super-ssg/javascript" class="i">JavaScript</a></li><li><a href="https://jacobp100.github.io/super-ssg/css" class="i">CSS</a></li><li><a href="https://jacobp100.github.io/super-ssg/custom-asset-handling" class="i j">Custom Asset Handling</a></li></ul><h6 class="g">Utils</h6><ul class="h"><li><a href="https://jacobp100.github.io/super-ssg/usetableofcontents" class="i">useTableOfContents</a></li></ul><h6 class="g">Notes</h6><ul class="h"><li><a href="https://jacobp100.github.io/super-ssg/babel" class="i">Babel</a></li></ul></div></nav><main><h1>Custom Asset Handling</h1><p>Almost all asset transforms consist of a transform function, a content object to read and write assets, then a React hook to get the content object. Most transform functions take in a url, read the contents of the file, transform it, then save the contents of the file — returning the url where it was saved to.</p>
<p>For example, a CSS transform may look like this.</p>
<pre><code><span class="k">import</span> { assetTransform, useContent } <span class="k">from</span> <span class="n">&quot;super-ssg&quot;</span>;

<span class="k">const</span> transformCss = <span class="l U">assetTransform</span>(<span class="k">async</span> (content, href) =&gt; {
  <span class="k">let</span> cssString = content.<span class="l U">read</span>(href);

  <span class="t">// E.g. cssString = someOptimiser(cssString)</span>

  <span class="k">const</span> href = content.<span class="l U">write</span>(cssString, { <span class="r">extension</span>: <span class="n">&quot;.css&quot;</span> });
  <span class="k">return</span> href;
});

<span class="k">const</span> <span class="l U">ExternalCss</span> = (<span class="-c">props</span>) =&gt; {
  <span class="k">const</span> content = <span class="l U">useContent</span>();
  <span class="k">const</span> href = <span class="l U">transformCss</span>(props.<span class="W">href</span>);
  <span class="k">return</span> <span class="o"><span class="p">&lt;<span class="q">link</span> <span class="r">href</span>=<span class="n">{href}</span> <span class="r">rel</span>=<span class="n">&quot;stylesheet&quot;</span> /&gt;</span></span>;
};
</code></pre>
<p>This might seem like extra code, but it also achieves a few things:</p>
<ul>
<li>It lets the page track which assets are used, so will automatically rebuild when any are changed</li>
<li>The results are cached</li>
</ul>
<p>Some important points when using transforms:</p>
<ul>
<li>Asset transforms must take <code>content</code> as the first parameter, then the remaining parameters <strong>must</strong> be JSON serializable</li>
<li>The transform function can be async — although it doesn’t have to be</li>
<li>You can return any data, including non-serializable data</li>
</ul>
<p>There’s a few cases where the development server restarts its node instance — such as when a JS file changes. In this case, the transform cache would normally be cleared, and all transforms must be recomputed after it restarts. For transforms with simple, serializable return values (e.g. returning a url — like above), we extract the cache before the node instance restarts, then restore it once it’s back up. If you want to opt into this behaviour — and your return value is serializable — you can add a second argument <code>{ cacheKey: &#x27;some-unique-string&#x27; }</code>.</p>
<h2>Built-in Transforms</h2>
<p>The following are exported so you can do your own pre-processing steps without losing the built-in functionality.</p>
<pre><code><span class="k">import</span> {
  transformCss,
  transformHtml,
  transformJs,
  transformSvg,
} <span class="k">from</span> <span class="n">&quot;super-ssg&quot;</span>;
</code></pre>
<p>For example, you could make a component to do your own CSS handling.</p>
<pre><code><span class="k">import</span> postcss <span class="k">from</span> <span class="n">&quot;postcss&quot;</span>;
<span class="k">import</span> spiffing <span class="k">from</span> <span class="n">&quot;postcss-spiffing&quot;</span>;
<span class="k">import</span> { assetTransform, useContent } <span class="k">from</span> <span class="n">&quot;super-ssg&quot;</span>;

<span class="k">const</span> transformCustomCss = <span class="l U">assetTransform</span>(<span class="k">async</span> (content, href) =&gt; {
  <span class="k">let</span> css = content.<span class="l U">read</span>(href);
  css = (<span class="k">await</span> postcss.<span class="l U">process</span>([<span class="l U">spiffing</span>()]).<span class="l U">process</span>(css, { <span class="r">from</span>: href })).<span class="W">css</span>;
  css = <span class="k">await</span> <span class="l U">transformCss</span>(content, css);

  <span class="k">const</span> href = content.<span class="l U">write</span>(css, { <span class="r">extension</span>: <span class="n">&quot;.css&quot;</span> });
  <span class="k">return</span> href;
});

<span class="k">const</span> <span class="l U">CustomCss</span> = (<span class="-c">props</span>) =&gt; {
  <span class="k">const</span> content = <span class="l U">useContent</span>();
  <span class="k">const</span> href = <span class="l U">transformCustomCss</span>(props.<span class="W">href</span>);
  <span class="k">return</span> <span class="o"><span class="p">&lt;<span class="q">link</span> <span class="r">href</span>=<span class="n">{href}</span> <span class="r">rel</span>=<span class="n">&quot;stylesheet&quot;</span> /&gt;</span></span>;
};
</code></pre>
<p>There is currently no way to customise the handling MDX files.</p></main></body></html>